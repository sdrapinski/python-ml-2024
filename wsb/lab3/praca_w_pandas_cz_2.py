# -*- coding: utf-8 -*-
"""Praca w Pandas cz.2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/124I9rkbmL9wOL6r_nH-ulQr2t-SjVnVW

###**Importuję bibliotekę pandas**
"""

import pandas as pd

"""Podstawową strukturą danych w bibliotece pandas jest **Data Frame** czyli inaczej ramka danych.

###**Tworzymy ramkę danych**

Ramkę danych możemy utworzyć ze zwykłego słownika języka Python.

Aby ramka danych została utworzona, wszytskie kolumny muszą mieć identyczną długość.

Nawet jeżeli będziemy mieli brakujące dane, muszą one być reprezentowane przez wartości *Nan* (*ang. Not a number*).
"""

df = pd.DataFrame({"column1": [1, 2, 3, 4, 5], "column2" : [6, 7, 8, 9, 10], "column3" : ["A", "B", "C", "D", "E"]})
df

"""###**Zwracamy typ obiektu df.**"""

type(df)

"""###**Wyświetlamy poczatek ramki danych - pierwsze pięć wierszy.**"""

df.head()

"""Jeżeli podamy jako parametr medoty head jakąś liczbę - taka liczba wierszy zostanie zwrócona."""

df.head(3)

"""###**Wyświetlamy koniec ramki danych - ostatnie 5 wierszy**"""

df.tail()

"""Podobnie jak w przypadku pracy z metodą *head()*, możemy zdefiniować liczbę wierszy, które chcemy aby zostały zwrócone."""

df.tail(3)

"""Jeżeli chcemy wyświetlić zawartość konkretnego elementu ramki danych, możemy to zrobić odwołując się przykładowo do danej kolumny.

Robimy to wpisując wewnątrz nawiasów kwadratowych nazwę danego elemntu - w tym przypadku nazwę kolumny.
"""

df["column1"]

"""Innym typem danych dostarczanym przez bibliotekę pandas jest **seria** (*ang. Series*)

Seria to typ danych, ktory posiada indeks.

mamy więc możliwość odwoływania się do poszczególnych elementów za pomocą **indeksów**.
"""

type(df["column1"])

"""Pandas w dość łatwy sposób pozwala definiować warunki na wartościach zawartych w kolumnie.

Działanie takie umożliwia między innymi filtrowanie wartości.

###**Filtrowanie konkretnych wartości**

Zwrócone dane są typu Series, wartości z tej serii odpowiadają wynikowi porównania tego co pierwotnie się w serii znajdowało, względem wartoci, którą mamy po prawej stronie warunku.
"""

df["column1"] <=3

"""Mamy również możliwość potraktowania powyższego działania jako filtr - w efekcie zwrócona zostanie ranka danych, ktora będzie zawierała dane spełniajace warunek filtru."""

df[df["column1"] <=3]

"""###**Odwołanie do konkretnego wiersza**

Sposób na odwoływanie się do poszczególnych wierszy ramki danych.

Mam tu na myśli wiersze o indeksie numerycznym.
"""

df.iloc[0]

"""Możemy również odwołać się do konkretnego elementu ranki danych."""

df.iloc[0, 0]

"""Wyświetlimy wszystkie wiersze (:) kolumny o indeksie 0."""

df.iloc[:, 0]

"""###**Manipulacja indeksami.**

Indeks automatyczny - indeks utworzony na zakresie od 0 do 5 z krokiem 1.
"""

df.index

df.set_index("column3")

"""Na tym etapie warto wskazać, iż większość metod w bibliotece pandas zwraca pewne tymczasowe wartości zmodyfikowanych ramek danych.

Zatem wykonanie takiej metody nie oznacza, że dokonujemy zmian w zmiennej df, tylko tworzymy nową ramkę danych, która będzie odpowienio zmodyfikowana względem tej, którą już mamy.

Jeżeli chcielibysmy wynik działania metody zapisać w ramce danych musimy działanie to przypisać do zmiennej df.

###**Odwołanie do wierwsza ramki danych o indeksie nienumerycznym.**
"""

df = df.set_index("column3")
df

df.loc["A"]

"""###**Modyfikacja danych**

###Uzupełnianie / zastępowanie danych
"""

df["column1"].loc["A"] = None
df

df["column1"]

"""Warto w tym miejscu zwrócić uwagę na dość istotną kwestię. Mianowicie kiedy uprzednio wyswietlaliśmy typ danych były one typu int64 czyli typ całkowitoliczbowy.

Po zmianie wartości "A" na typ "NaN" typ danych zmienił się na float64 czyli typ zmiennoprzecinkowy.

Wynika to z faktu, iż wartości None wymuszają niejako ten typ.

Dlatego też ranka danych została zmodyfikowana aby typ był odpowiedni.

###Inny przykład zastępowania danych

*Jak uzupełniać brakujące dane?*

Bardzo często w rzeczywistych przykładach zdarza nam się, że w niektorych kolumnach występują wartości *NaN*.

Do zastępowania wartości NaN możemy wykorzystać metodę *fillna()*

Stosując metodę fillna() możemy wybrać względem, której osi będziemy stosować podmianę wartości Nan na inną wartość.
"""

df.fillna(0)

df

df.fillna(0, inplace=True)
df

"""###**Sortowanie danych**

Ramki danych możemy sortować według indeksu i według wartości w poszczególnych kolumnach.

Żeby pokazać dzialanie metody index_sort sortuje malejąco.
"""

df.sort_index(ascending=False)

df.sort_values(by="column1")

"""###**Wczytywanie danych do ramki danych z plików**

###Wczytanie danych z repozytorium git na serwisie github
"""

import os

"""###Sprawdzam ścieżkę"""

!pwd

"""###Tworzymy folder, do ktorego wczytujamy dane"""

os.mkdir("data")

"""###Zmieniam bierzącą ścieżkę właśnie na folder *data*"""

os.chdir("data")

!pwd

"""###Klonuję repozytorium"""

!git clone https://github.com/pszajows/dane_do_lekcji_o_pandasie.git

"""###Listuję zawartość folderu"""

!ls -l

"""###Przechodzę do folderu"""

os.chdir("dane_do_lekcji_o_pandasie")

!pwd

"""Pobrany folder zawiera kilka plików z danymi w różnych formatach:

plik excel (.xlsx)

pliki csv (.csv) - kolumny rozdzielone przecinkami lub średnikami

plik tsv (.tsv) - kolumny rozdzielone są znakami tabulacji




"""

!ls

"""###Wczytaniue danych z pliku excela

Dane w pliku excela zapisywane są w formacie binarnym.
"""

df = pd.read_excel("przykladowe_dane.xlsx")
df

"""###Zwracamy typ przechowujący czas - Timestamp

(pojedynczy element serii)

Pojedynczy element serii *Timestamp* - znacznik czasu (binarna reprezentacja czasu, z której możemy uzyskać infoamcję o roku, miesiacu, dniu, godzinie itd.)
"""

type(df["czas"].iloc[0])

"""###Wczytujemy dane z pliku tekstowego, w którym kolumny rozdzielimy przecinkami, a znakiem dzisiętnym będzie znak "."

"""

df = pd.read_csv("przykladowe_dane.csv")
df

"""Sprawdźmy typ danych przechowywanych w kolumnie *czas*."""

type(df["czas"].iloc[0])

"""Jak możemy zauwazyć zwracany typ danych to *string*.

Bardzo istotne jest to, by wszystkie dane czasowe przechowywane były w odpowiednim formacie - wskazującym, iż jest to czas i pozwalał nam tę zmienną przetwarzać.

Konieczne zatem jest przekonwertowanie wartości tekstowych na wartości w odpowiednim formacie - Timestamp (format czasu).
"""

pd.to_datetime(df["czas"])

pd.to_datetime(df["czas"]).iloc[0]

"""###Inny, rekomendowany sposób przekonwertrowania danych

Przetwarzanie danych zawartych w ranmce danych za pomocą metody *apply()*.

Metodę tę można stosować na ramkach danych jak i na seriach.
"""

df["czas"] = df["czas"].apply(pd.to_datetime)
df

"""###Działanie funkcji *to_datetime()*"""

pd.to_datetime("1.01.2020")

pd.to_datetime("97-12-02")

pd.to_datetime("04/12/1967")

pd.to_datetime("04|12|1967", format= "%m|%d|%Y")

"""###Wczytujemy dane z pliku tekstowego, w którym kolumny rozdzielimy średnikami, a znakiem dzisiętnym będzie znak ","

Ważne by zaraz po wczytaniu danych, wyświetlić ich zawartość.

W ten sposób jesteśmy w stanie zweryfikować, przynajmniej wstępnie czy nasze dane zostały wczytane poprawnie.

Mamy jedną kolumnę, która składa się z nazw wszytkich kolumn, które były przewidziane i pomiędzy, którymi znajdują się średniki.

Jest to bardzo dobry przykład ranki danych, ktora posiada więcej niż jeden indeks tak zwany **multiindeks**.
"""

df = pd.read_csv("przykladowe_dane2.csv")
df

df = pd.read_csv("przykladowe_dane2.csv", sep=";", decimal=',')
df

df["czas"] = df["czas"].apply(pd.to_datetime)
df

"""###Wczytujemy dane z pliku tekstowego, w którym kolumny rozdzielimy tabulatorami."""

df = pd.read_csv("przykladowe_dane.tsv", sep="\t")
df

df["czas"] = df["czas"].apply(pd.to_datetime)
df

"""###**Funkcja grupująca group_by()**

Uruchamiając tę metodę w takiej postaci na wyjściu otrzymamy obiekt *DataFrameGroupBy* - specjalna klasa, która reprezentuje pogrupowaną ramkę danych.

Pogrupowana ranka danych może być wejściem do kolejnej funkcji, która coś z tak pogrupowanymi danymi będzie chciała  zrobić.
"""

df.groupby("czujnik")

"""###Zwracamy wartość średnią dla pogrupowanych czujników A i B."""

df.groupby("czujnik").mean()

"""###Inne wartości:"""

df.groupby("czujnik").max()

df.groupby("czujnik").min()

"""###**Co zrobić żeby naszą ramkę danych potraktować jak szereg czasowy i policzyć średnią ruchomą dla wartości rejestrowanych na poszczególnych czujnikach?**

W naszej ramce dancyh ustawiamy czas jako indeks, a wartości 1 i 2 dla czujnika A i B postawić koło siebie

Na poczatku ustawiamy jako indeks - czas, nastepnie kolejne metody będziemy wywoływać na na ramce, która została zwrocona jako wynik działania poprzedniej metody.


W metodzie *pivot()* musimy okreslić, która kolumna będzie zawierala wartości, które ma stanowić podstawę do utworzenia kolejnych kolumn - parametr *columns*.

Na końcu musimy podac, które kolumny mają zostać zamienione na wartości - parametr *values* - które kolumny będa stanowiły wartości nowych kolumn.

Finalnie zamieniliśmy naszą rankę danych na szereg czasowy.
"""

df = df.set_index("czas").pivot(columns="czujnik", values = ["wartosc1", "wartosc2"])
df

"""###Następnie spróbujmy pogrupować dane czasowo - uśrednijmy dane z kolejnych dni.

Przykładowo: średnia z dnia pierwszego, średnia z dnia drugiego itd.

Parametrem podanym w resample regulujemy granularność szeregu czasowego.


"""

df = df.resample("1d").mean()
df

"""###**Średnia ruchoma** *(ang. moving avrage, rolling avrage)*

Funkcją agregującą jest metoda *rolling()*.

Agregowanie danych w okienkach czasowych.

W tym przypadku okienko czasowe wynosi 5h.
"""

df = df.set_index("czas").pivot(columns="czujnik", values = ["wartosc1", "wartosc2"]).rolling(5).mean()

df

"""W rezultacie otrzymujemy wartości rolującej się / poruszajacej się średniej.

###**Wizualizacja ranki danych**

###**Import biblioteki matplotlib, moduł pyplot**
"""

import matplotlib.pyplot as plt

"""###Okreslamy rozmiar wykresu

(Wymiary wykresu podajemy w umownych jednostkach.)

(Pierwsza wartość to szerokość, a druga to wysokość.)
"""

plt.figure(figsize=(18, 5))
plt.plot(df.set_index("czas").pivot(columns="czujnik", values = ["wartosc1", "wartosc2"]).rolling(5).mean()["wartosc2"]["B"][:72], label= "Rolling Avg.", color="red")
plt.plot(df.set_index("czas").pivot(columns="czujnik", values = ["wartosc1", "wartosc2"])["wartosc2"]["B"][:72], label= "Measurement", color="black")
plt.legend()
pass

"""Średnia ruchoma nieco wygładza warości szeregu czasowego.

###**Przykład**
"""

!pip install yfinance --upgrade --no-cache-dir
import yfinance as yf
import pandas as pd
import pandas_datareader.data as web
import matplotlib.pyplot as plt

start_date = "2023-01-1"
end_date = "2023-12-31"

data = yf.download(tickers="TSLA", start=start_date, end=end_date)
data

close = data['Close']
ax = close.plot(title='Tesla')
ax.set_xlabel('Date')
ax.set_ylabel('Close')
ax.grid()
plt.show()